const $path = require("path");
const { eachFileRecursive, readdir, readFile, writeFile, posixPath, mkdir, rm } = require("../util");

function mapClass(name) {
	switch (name) {
	case "CategoryAxis":
	case "CategoryDateAxis":
	case "Axis":
	case "DateAxis":
	case "ValueAxis":
	case "DurationAxis":
	case "GaplessDateAxis":
		return `${name}<AxisRenderer>`;
	default:
		return name;
	}
}

function getChunk(path) {
	const parts = path.split(/\//g);

	if (parts[0] === "core") {
		return "../../../index";

	} else if (parts[0] === "charts") {
		let name = parts[1];

		if (name === "wordcloud") {
			name = "wc";
		} else if (name === "funnel" || name === "pie") {
			name = "percent";
		}

		return `../../../${name}`;

	} else if (parts[0] === "plugins") {
		return `../../../plugins/${parts[1]}`;

	} else {
		throw new Error("Unrecognized path: " + path);
	}
}

function chunkName(path) {
	return path.replace(/\.\.\//g, "").replace(/\.js$/, "").replace(/\//g, "_");
}

async function lookup(classes, path) {
	await eachFileRecursive(path, async (path) => {
		if ($path.extname(path) === ".ts") {
			const file = await readFile(path);

			for (let [_, name] of file.matchAll(/public +static +className: *string *= *"([^"]+)"/g)) {
				classes[name] = {
					path: $path.join($path.dirname(path), $path.basename(path, ".ts")),
					className: name,
				};
			}
		}
	});
}

async function writeClasses(state, classes, keys) {
	const imports = [];
	const properties = [];

	keys.forEach((key) => {
		const { path, className } = classes[key];
		const classType = mapClass(className);

		const importPath = posixPath($path.relative(state.dir("src", ".internal", "core"), path));

		imports.push(`import type { ${className} } from "./${importPath}.js";`);
		properties.push(`\t"${key}": ${classType};`);
	});

	await writeFile(state.dir("src", ".internal", "core", "Classes.ts"), `/**
 * This file is automatically generated by \`yarn generate-classes\`.
 * DO NOT MANUALLY EDIT IT OR YOUR CHANGES WILL BE LOST!
 */

${imports.join("\n")}

export interface IClasses {
${properties.join("\n")}
}
`);
}

async function writeJson(state, classes, keys) {
	const imports = [];
	const types = [];
	const properties = [];
	const propertiesScript = [];

	keys.forEach((key) => {
		const { path, className } = classes[key];

		const relPath = posixPath($path.relative(state.dir("src", ".internal"), path));

		const chunk = getChunk(relPath);

		imports.push(`import type { ${className} } from "./${chunk}";`);
		types.push(`\t"${key}": () => Promise<typeof ${className}>;`);
		properties.push(`\t"${key}": () => import(/* webpackExports: "${className}", webpackChunkName: "json_${chunkName(chunk)}" */ "./${chunk}").then((m) => m.${className}),`);
		propertiesScript.push(`\t"${key}": () => import(/* webpackExports: "${className}", webpackMode: "weak" */ "./${chunk}").then((m) => m.${className}),`);
	});

	await writeFile(state.dir("src", ".internal", "plugins", "json", "Classes.ts"), `/**
 * This file is automatically generated by \`yarn generate-classes\`.
 * DO NOT MANUALLY EDIT IT OR YOUR CHANGES WILL BE LOST!
 */

${imports.join("\n")}

export interface IClasses {
${types.join("\n")}
}

const classes: IClasses = {
${properties.join("\n")}
};

export default classes;
`);

	await writeFile(state.dir("src", ".internal", "plugins", "json", "Classes-script.ts"), `/**
 * This file is automatically generated by \`yarn generate-classes\`.
 * DO NOT MANUALLY EDIT IT OR YOUR CHANGES WILL BE LOST!
 */

${imports.join("\n")}

export interface IClasses {
${types.join("\n")}
}

const classes: IClasses = {
${propertiesScript.join("\n")}
};

export default classes;
`);
}

module.exports = async (state) => {
	const classes = {};

	await lookup(classes, state.dir("src", ".internal"));

	const keys = Object.keys(classes);

	keys.sort((x, y) => {
		if (x === y) {
			return 0;
		} else if (x < y) {
			return -1;
		} else {
			return 1;
		}
	});

	await Promise.all([
		writeClasses(state, classes, keys),
		writeJson(state, classes, keys),
	]);
};
